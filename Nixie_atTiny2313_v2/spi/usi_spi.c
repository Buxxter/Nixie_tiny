//Код для работы USI в качестве SPI без использования прерываний (на примере ATtiny2313)
//Автор s_black www.embed.com.ua
//Функции работы SPI написаны на основе даташита (переписаны из asm на Си)
//Для режима MASTER есть две функции приёма/передачи. Использовать в зависимости от поставленных задач.
//Если не нужна большая скорость SPI - используйте первую

#include "usi_spi.h"


void usi_spi_master_init (void)
{
    DDR_SPI |=  (1<<DO);  //линия выхода данных - выход
	DDR_SPI |=  (1<<UCSK);//линия тактирующего сигнала - выход
	DDR_SPI |=  (1<<SS);  //линия выбора кристалла - выход
	DDR_SPI &= ~(1<<DI);  //линия входа данных - вход
}

unsigned char usi_spi_send_receive (unsigned char data_w)//функция передачи/приёма байта по USI
{
    USIDR = data_w;//передаваемые данные в сдвиговый регистр
	USISR |= (1<<USIOIF);//сбрасываем флаг
	while(!(USISR & (1<<USIOIF)))//пока нет флага окончания передачи
	{
	   USICR |= (1<<USIWM0) | (1<<USICS1) | (1<<USICLK) | (1<<USITC);//формируем тактирующие импульсы
	}
	return (USIDR);//возвращаем полученные данные
}


/*unsigned char SPI_WR_M (unsigned char data_w)//функция передачи/приёма байта по USI с max скоростью (до Fclk/2)
{
    //unsigned char a,b;
    //                                                     USISIE USIOIE USIWM1 USIWM0 USICS1 USICS0 USICLK USITC                
    //a = (1<<USIWM0)|(0<<USICS0)|(1<<USITC);//                0      0     0      1     0      0      0      1
	//b = (1<<USIWM0)|(0<<USICS0)|(1<<USITC)|(1<<USICLK);//    0      0     0      1     0      0      1      1
    USIDR = data_w;//передаваемые данные в сдвиговый регисть
    USICR = 0b00010001;//и формируем тактирующие импульсы программно
    USICR = 0b00010011;
    USICR = 0b00010001;
    USICR = 0b00010011;
	USICR = 0b00010001;
    USICR = 0b00010011;
	USICR = 0b00010001;
    USICR = 0b00010011;
	USICR = 0b00010001;
    USICR = 0b00010011;
	USICR = 0b00010001;
    USICR = 0b00010011;
	USICR = 0b00010001;
    USICR = 0b00010011;
	USICR = 0b00010001;
    USICR = 0b00010011;
	return (USIDR);//возвращаем полученные данные
}*/

void USI_init_SPI_S (void)
{
    DDR_SPI |=  (1<<DO);  //линия выхода данных - выход
	DDR_SPI &= ~(1<<UCSK);//линия тактирующего сигнала - вход
	DDR_SPI &= ~(1<<SS);  //линия выбора кристалла - вход
	DDR_SPI &= ~(1<<DI);  //линия входа данных - вход
    USICR |= (1<<USIWM0) | (1<<USICS1);//трёхпроводный режим USI, внешний источник тактового сигнала
}

unsigned char SPI_WR_S (unsigned char data_w)//функция передачи/приёма байта в режиме SLAVE
{
    USIDR = data_w;//передаваемые данные заносим в сдвиговый регистр
    USISR |= (1<<USIOIF);//сбрасываем флаг
	while(!(USISR & (1<<USIOIF)));//и ждём его появления (конца передачи)
	return (USIDR);//возвращаем принятое значение
}

//Для работы в режиме MASTER расскоментируйте эту главную функцию
/*
int main (void)
{
    unsigned char data_w = 0, data_r;//переменные передаваемых и принимаемых данных

    USI_init_SPI_M ();//инициализация USI как SPI
    PORTD |= _BV(PD1); //линия кнопки вход с резистором
	PORT_SPI &= ~(1<<SS);//выбираем кристалл, т.е. 8-ю мегу
    for(;;)//бесконечный цикл
    {    
        if(bit_is_clear(PIND, PD1))//если нажата кнопка
        {
            _delay_ms(50);//антидребезг
            if(bit_is_clear(PIND, PD1))//если кнопка всё-таки нажата
            {    
                if(++data_w > 9) data_w = 0; //проверяем, чтобы счётчик (передаваемые данные) не вышел за пределы
                data_r = SPI_WR_M(0x30+data_w);//отправляем по SPI ANSI-код цифр от 0 до 9, а принятые данные сохраняем в переменной data_r 
			}
			while((bit_is_clear(PIND, PD1)));//чтоб не было автоповтора
		}
	}
}
*/

//Для работы в режиме SLAVE расскоментируйте эту главную функцию
/*int main (void)
{
    unsigned char data_w = 'K', data_r;//переменные передаваемых и принимаемых данных

    USI_init_SPI_S ();//инициализация USI как SPI
    lcd_init();//инициализация ЖКИ
	lcd_com(0x80);//курсор в начало строки
	lcd_dat('O');lcd_dat('K');//пишем ОК
    for(;;)//бесконечный цикл
    {    
        if(bit_is_clear(PIN_SPI, SS))//если выбран наш кристалл
        {
            data_r = SPI_WR_S(data_w);//принимаем по SPI байт данных, одновременно передавая литеру К 
            lcd_dat(data_r);//отображаем на ЖКИ, что приняли
		}
	}
}*/

